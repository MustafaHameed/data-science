}
make.power <- function(n) {
pow <- function(x) {
x^n
}
pow
}
cube <- make.power(3)
square <- make.power(2)
cube
cube(3)
square(3)
ls(environment(cube))
get("n", environment(sube))
get("n", environment(cube))
y <- 10
f <- function(x) {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
f(3)
x <- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02"))
x <- Sys.time()
x
p <- as.POSIXlt(x)
names(unclass(p))
p$sec
x <- Sys.time()
x ##already in 'POSIXct' format
unclass(x)
x$sec
p <- as.POSIXlt(x)
names(unclass(p))
p$sec
datestring <- c("January 10, 2012 10:40", "December 9, 2011 9:10")
x <- strptime(datestring, "%B %d, %Y %H:%M")
x
class(x)
?strptime
x <- as.Date("2012-03-01") y <- as.Date("2012-02-28")
x-y
x <- as.POSIXct("2012-10-25 01:00:00")
y <- as.POSIXct("2012-10-25 06:00:00, tz = "GMT")
y-x
x <- as.Date("2012-03-01")
y <- as.Date("2012-02-28")
x-y
x <- as.POSIXct("2012-10-25 01:00:00")
y <- as.POSIXct("2012-10-25 06:00:00, tz = "GMT")
y-x
x <- as.Date("2012-03-01")
y <- as.Date("2012-02-28")
x-y
x <- as.POSIXct("2012-10-25 01:00:00")
y <- as.POSIXct("2012-10-25 06:00:00", tz = "GMT")
y-x
str(applu)
str(apply)
mean(x)
traceback()
recover()
mean(x)
recover()
lm(y - x)
traceback
trackback()
lm(y - x)
trackback()
m <- matrix(1:6, 2, 3)
m
reverse(m)
inverse(m)
invert(m)
inv(m)
solve(m)
solve(m) * m
?solve
solve(m, 2)
solve(m, 3)
solve(m, c(2, 3))
ginv(m)
m <- matrix(1:4, 2, 2)
m
solve(m)
## These functions are used to create a special object that stores a matrix
## and cache's its inverse.
## The first function, makeCacheMatrix creates a special "matrix" and cache
## its inverse
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- fuction(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(z) inverse <<- z
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv
getinv = getinv)
}
## The second function, cacheSolve computes the inverse of the special "matrix"
## returned by makeCacheMatrix. If the inverse has already been calculated (and
## the matrix has not changed), then the cacheSolve should retrieve the inverse
## from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinv()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
matrix <- x$get()
inverse <- solve(matrix, ...)
x$setinv(inverse)
inverse
}
## Example:
matr <- makeCacheMatrix(matrix(1:4, 2, 2))
cacheSolve(matr)
cacheSolve(matr)  ## "getting cached inverse"
matr$set(matrix(5:8, 2, 2))
cacheSolve(matr)
cacheSolve(matr)  ## "getting cached inverse"
## These functions are used to create a special object that stores a matrix
## and cache's its inverse.
## The first function, makeCacheMatrix creates a special "matrix" and cache
## its inverse
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- fuction(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(z) inverse <<- z
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv
getinv = getinv)
}
## The second function, cacheSolve computes the inverse of the special "matrix"
## returned by makeCacheMatrix. If the inverse has already been calculated (and
## the matrix has not changed), then the cacheSolve should retrieve the inverse
## from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinv()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
matrix <- x$get()
inverse <- solve(matrix, ...)
x$setinv(inverse)
inverse
}
## Example:
matr <- makeCacheMatrix(matrix(1:4, 2, 2))
cacheSolve(matr)
cacheSolve(matr)  ## "getting cached inverse"
matr$set(matrix(5:8, 2, 2))
cacheSolve(matr)
cacheSolve(matr)  ## "getting cached inverse"
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- fuction(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(z) inverse <<- z
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
# i will store the inverse
inv <- NULL
# set should be used to alter the matrix
# it invalidates the cache
set <- function(y) {
x <<- y
inv <<- NULL
}
# get simply returns the raw matrix
get <- function() {
x
}
# setinv sets the inv variable
# should be used only by cacheSolve
setinv <- function(i) {
inv <<- i
}
# getinv gets the cached inverse
getinv <- function() {
inv
}
# return the special matrix
list(set = set,
get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- fuction(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(z) inverse <<- z
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {
x
}
setinv <- function(i) {
inv <<- i
}
getinv <- function() {
inv
}
list(set = set,
get = get,
setinv = setinv,
getinv = getinv)
}
## These functions are used to create a special object that stores a matrix
## and cache's its inverse.
## The first function, makeCacheMatrix creates a special "matrix" and cache
## its inverse
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- fuction(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(z) inverse <<- z
getinv <- function() inverse
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## The second function, cacheSolve computes the inverse of the special "matrix"
## returned by makeCacheMatrix. If the inverse has already been calculated (and
## the matrix has not changed), then the cacheSolve should retrieve the inverse
## from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinv()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
matrix <- x$get()
inverse <- solve(matrix, ...)
x$setinv(inverse)
inverse
}
## Example:
matr <- makeCacheMatrix(matrix(1:4, 2, 2))
cacheSolve(matr)
cacheSolve(matr)  ## "getting cached inverse"
matr$set(matrix(5:8, 2, 2))
cacheSolve(matr)
cacheSolve(matr)  ## "getting cached inverse"
str(lm)
sample(letters)
set.seed(1)
rpois(5, 2)
System.time(readLines("http://www.jhspf.edu"))
system.time(readLines("http://www.jhspf.edu"))
system.time(readLines("http://www.jhsph.edu"))
hilbert <- function(n) {
i <- 1:n
1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
hilbert <- function(n) {
i <- 1:n
1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
hilbert <- function(n) {
i <- 1:n
1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
hilbert <- function(n) {
i <- 1:n
1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
hilbert <- function(n) {
i <- 1:n
1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
hilbert <- function(n) {
i <- 1:n
1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
system.time({
n <- 1000
r <- numeric(n)
for (i in 1:n) {
x <- rnorm(n)
r[i] <- mean(x)
}
})
sample.interval=10000
ls()
dir()
